<!-- Front page HTML -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <title> Flask App </title>
        <link rel = "stylesheet" type= "text/css" href = " {{ url_for('static', filename = 'style.css') }}">
    </head>
    <body>
    <!-- This code connects WebsocketsIO to the index.html file, so it can update the
     display in real-time. -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
        <script>
        var socket = io.connect('http://' + document.domain + ':' + location.port);

        // Waits to receive 'update_data' from socket's emit function in app.py
        // Once it receives it, it runs the function.
        // The parseFloat and toFixed(2) ensure that the data read is a float up to 2 decimal places.
        socket.on('update_data', function(data) {
            
            // Does nothing as of now

            console.log("Received data", data);
        });
        </script>

        <div class = "title">
            <img src="https://sites.tufts.edu/racing/files/2020/04/cropped-newlogo-2.png"
            width="337.5" length="750"/>
        </div>
        
        
        <h1>Houston - Tufts Racing Telemetry Webapp</h1>
        <!-- Write up-to-date sensor readings here!!! -->
         <style>
            table, th, td {
            border: 1px solid black; border-collapse: collapse;
            }
        </style>
        <div id = "tableContainer"></div>
            <script>

                const container = document.getElementById('tableContainer');
                const table = document.createElement('table');
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                const headers = ['Name', 'Value'];
                headers.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                const tbody = document.createElement('tbody');
                const data = [];
            
                data.forEach(rowData => {
                    const row = document.createElement('tr');
                    for (const key in rowData) {
                        const cell = document.createElement('td');
                        cell.textContent = rowData[key];
                        row.appendChild(cell);
                    }
                    tbody.appendChild(row);
                    });
                table.appendChild(tbody);
                container.appendChild(table);
                


                /* 
                    renderTable
                    
                    renders real-time data table with upated data via data array
                
                
                */
                function renderTable() {
                    // Get all rows in tbody
                    const rows = tbody.querySelectorAll('tr');

                    rows.forEach((row, rowIndex) => {
                        const cells = row.querySelectorAll('td');
                        cells[0].textContent = data[rowIndex].name;
                        cells[1].textContent = data[rowIndex].value;
                    });
                }
                
                
                /*
                    updateTable
                
                    Updates real-time table with all incoming real-time data

                    input(s): data array to be updated in entirety with incoming data
                */  
                async function updateTable(data)
                {

                    // make it flexible to however many unique incoming readings need to be read
                    try {


                        const response1 = await fetch('/get_test/1'); // Replace with your actual API endpoint
                        if (!response1.ok) {
                        throw new Error(`HTTP error! status: ${response1.status}`);
                        }
                        const response2 = await fetch('/get_test/36');
                        if (!response2.ok) {
                        throw new Error(`HTTP error! status: ${response2.status}`);
                        }
                        const response3 = await fetch('/get_test/37');
                        if (!response3.ok) {
                        throw new Error(`HTTP error! status: ${response3.status}`);
                        }
                        const reading1 = await response1.json();
                        const reading2 = await response2.json();
                        const reading3 = await response3.json();

                        data[0].name = reading1.name;
                        data[1].name = reading2.name;
                        data[2].name = reading3.name;
                        
                        data[0].value = reading1.data;
                        data[1].value = reading2.data;
                        data[2].value = reading3.data;

                        renderTable();
                    }
                    catch (error) {
                        console.error("Error fetching or parsing data:", error);
                    }
                }

            setInterval(() => {
                updateTable(data);
            }, 3000);
            </script> 
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
        <canvas class="graph" id="graph1" style="width:100%;max-width:700px"></canvas>
        <button onclick="clearGraph(g1)">Clear Graph</button>
        <canvas class="graph" id="graph2" style="width:100%;max-width:700px"></canvas>
        <button onclick="clearGraph(g2)">Clear Graph</button>
        <canvas class="graph" id="graph3" style="width:100%;max-width:700px"></canvas>
        <button onclick="clearGraph(g3)">Clear Graph</button>
        <script>   
            // TODO: we need to move these functions to a separate file eventually!

            /*
                updateGraphs
            
                Adds the most recently grabbed datapoints from 3 preexisting sensors,
                and adds it to its corresponding chart.

                input(s): size-3 array of sensor ids
                notes: 
                    - saves chart to cache based on CANVAS ID (see chartjs documentation),
                    - is async
                    - sensor(s) with given id must exist within database

            */
            async function updateGraphs([sid1,sid2,sid3])
            {
                // also TODO:
                // add button to exchange sensors in a specific graph
                // add button to view a specific sensor in table mode (and associated page)
                
                try{
                    const response1 = await fetch('/get_test/' + sid1); // Replace with your actual API endpoint
                    if (!response1.ok) {
                    throw new Error(`HTTP error! status: ${response1.status}`);
                    }
                    const response2 = await fetch('/get_test/' + sid2);
                    if (!response2.ok) {
                    throw new Error(`HTTP error! status: ${response2.status}`);
                    }
                    const response3 = await fetch('/get_test/' + sid3);
                    if (!response3.ok) {
                    throw new Error(`HTTP error! status: ${response3.status}`);
                    }
                    const reading1 = await response1.json();
                    const reading2 = await response2.json();
                    const reading3 = await response3.json(); 
                    

                    // update graphs
                    g1.data.labels.push(reading1.timestamp);
                    g1.data.datasets[0].data.push(reading1.data);
                    g2.data.labels.push(reading2.timestamp);
                    g2.data.datasets[0].data.push(reading2.data);
                    g3.data.labels.push(reading3.timestamp);
                    g3.data.datasets[0].data.push(reading3.data);

                    g1.update();
                    g2.update();
                    g3.update();

                    // save chart to client's cache so that it can be reloaded on refresh
                    saveToSessionStorage(g1.canvas.id, {
                        labels: g1.data.labels,
                        datasets: g1.data.datasets.map(ds => ({
                            label: reading1.name + " Over Time",
                            backgroundColor: ds.backgroundColor,
                            borderColor: ds.borderColor,
                            data: ds.data
                        }))
                    })
                    saveToSessionStorage(g2.canvas.id, {
                        labels: g2.data.labels,
                        datasets: g2.data.datasets.map(ds => ({
                            label: reading2.name + " Over Time",
                            backgroundColor: ds.backgroundColor,
                            borderColor: ds.borderColor,
                            data: ds.data
                        }))
                    })
                    saveToSessionStorage(g3.canvas.id, {
                        labels: g3.data.labels,
                        datasets: g3.data.datasets.map(ds => ({
                            label: reading3.name + " Over Time",
                            backgroundColor: ds.backgroundColor,
                            borderColor: ds.borderColor,
                            data: ds.data
                        }))
                    })
                }
                catch (error) {
                    console.error("Error fetching or parsing data:", error);
                }

            }

            async function clearGraph(g) {
                g.data.labels = [];
                g.data.datasets[0].data = [];
                g.update();

                saveToSessionStorage(g.canvas.id,
                {
                    labels: [],
                    datasets: [{
                        label: "",
                        backgroundColor:"rgba(255,255,255,1.0)",
                        borderColor: "rgba(0,0,255,0.1)",
                        data: []
                        }]
                });
                console.log("graph " + g + " cleared...");
            }
            /*
                saveToSessionStorage
            
                Given chart name and cachable chart data, saves chart data in user's browser cache

                input(s): name/key to save chart data field as, chart data field to be cached
            */
            function saveToSessionStorage(name, data) {
                // sessionStorage can only store strings, so we must serialize the data to JSON
                sessionStorage.setItem(name, JSON.stringify(data));
            }


            /*
                loadFromSessionStorage
            
                Given name of chart to load, return chart data from user's browser cache, 
                if there exists any. Else, return a fresh instance of chart data

                input(s): name under which chart data was saved as (in saveToSessionStorage)
            */
            function loadFromSessionStorage(name) {
                // filler values to put into fresh chart
                const xValues = [];
                const yValues = [];


                const storedData = sessionStorage.getItem(name);
                if (storedData) {
                    // Deserialize the JSON string back into a JavaScript object
                    return JSON.parse(storedData);
                }
                // Return a default data structure if nothing is saved yet
                return {
                    labels: xValues,
                    datasets: [{
                        label: name,
                        backgroundColor:"rgba(255,255,255,1.0)",
                        borderColor: "rgba(0,0,255,0.1)",
                        data: yValues
                        }]
                };
            }

            // define chart(s) here
            const g1 = new Chart("graph1", {
                type: "line",
                data: loadFromSessionStorage("graph1"),
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: 'Sensor 1 Over Time'
                        }
                    }
                }
            });
            
            const g2 = new Chart("graph2", {
                type: "line",
                data: loadFromSessionStorage("graph2"),
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: 'Sensor 2 Over Time'
                        }
                    }
                }
            });

            const g3 = new Chart("graph3", {                
                type: "line",
                data: loadFromSessionStorage("graph3"),
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: 'Sensor 3 Over Time'
                        }
                    }
                }
            });

            setInterval(() => {
                updateGraphs([1, 36, 37]);
            }, 3000);
        </script>
            <div id="sensorExchange" class="modal">
            <div class="modal-content">
                <button class="close-button">&times;</button>
                <h2>Exchange Graphs</h2>
                <p>select sensor data to exchange here...</p>
            </div>
        </div>
        <button id="openPopup">Open Popup</button>



        <script>

            document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('sensorExchange');
            const openPopupBtn = document.getElementById('openPopup');
            const closeButton = document.querySelector('.close-button');

            openPopupBtn.onclick = function() {
                modal.style.display = 'block';
                openPopupBtn.style.display = 'none';
            }

            closeButton.onclick = function() {
                modal.style.display = 'none';
                openPopupBtn.style.display = 'block';
            }

            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            }
        });
        </script>
    </body>
</html>